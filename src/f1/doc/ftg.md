# 本文是 follow_the_gap（fg）雷达寻隙算法的说明文档

## 参数说明

1. BUBBLE_RADIUS 零值气泡半径

- 雷达传回来的数据队伍：`[3, 3, 3, 4, 5, 6, 7, 8, 1, 3, 4, 5]`
- 我们设定的“洁癖”参数：`BUBBLE_RADIUS = 2` （向左向右各看2个雷达数据）
- 找到最近的点`1`-->左右2个为安全气泡范围`7,8，1，3，4`-->更新雷达数据`[3, 3, 3, 4, 5, 6, 7, 8, 1, 3, 4, 5]`-->`[3, 3, 3, 4, 5, 6, 0, 0, 0, 0, 0, 5]`

2. PREPROCESS_CONV_SIZE 预处理卷积窗口大小
- 如果`PREPROCESS_CONV_SIZE = 3`（也即窗口大小为3，计算一个雷达数据需要窗口包含3个雷达数据）
- 我们以 `[..., 5, 6, 7, ...]` 中间那个 `6` 为例，解释他警告卷积窗口法计算后的新值。
- `6`-->`5+6+7/3=6`（参与平均的雷达数据一共有3个）

3. BEST_POINT_CONV_SIZE  最佳点卷积窗口大小
- 如果`BEST_POINT_CONV_SIZE = 5`（也即窗口大小为5，计算一个雷达数据的最佳值需要包含他左右一共5个雷达数据点）
- 比如一组雷达数据为`1，1，1，1，9，1，2，1，6，6，6，6，6，1，2`，前面的`9`看似是最远的点，但是他的最优值为`1+1+1+9+1+2/5=3`但是后面一组6的最优值为`6+6+6+6+6+1/5=5`，明细前面的`9`虽然很远但实际上无法通过，后面的一组`6`的中心才可以通过
- 选择后面一组`6`的中心作为目标航向点

4. MAX_LIDAR_DIST 雷达回传数据中可以作为有价值参考的最远阈值
- MAX_LIDAR_DIST=7.0 代表给雷达戴了一个近视眼镜，这个近视眼镜只能看到7m以内的雷达数据，7m之外的都按照7m处理
- 比如没戴眼睛前是`[3.5米, 8.1米, 5.2米, 15.0米, 6.9米]`戴上近视眼镜后`[3.5米, 7.0米, 5.2米, 7.0米, 6.9米]`，可以看到大于7米的都视为7米

5. STRAIGHTS_SPEED 直行速度 CORNERS_SPEED 拐角速度
- 若小车判断当前大体上处于直行道（即方向盘需要打的角度小于角度阈值），则保持该直行速度，反之切换为拐角速度（降速）

6. STRAIGHTS_STEERING_ANGLE 判断是否是拐角的角度阈值
- 根据目标航向点计算出当前需要方向盘要打的角度
- 如果`STRAIGHTS_STEERING_ANGLE = 0.2`（弧度）
- 如果计算出现在需要打的角度为`0.1`弧度，则小于`0.2`弧度，认定为直行，保持速度为STRAIGHTS_SPEED直行速度

7. radians_per_elem = 0.00436  相邻雷达点之间的弧度

## 数据预处理（戴上“近视眼镜”并“眯起眼”看路）
1. 限制视野：小车首先会忽略掉侧面和后面的数据，只看正前方大约180度的范围。
2. 强制近视 (MAX_LIDAR_DIST = x)：它会检查所有雷达的距离数据，任何超过7.0米的，都一律当作7.0米。这可以防止被远方不相干的开阔地分心。
3. 雷达数据平滑 (PREPROCESS_CONV_SIZE = x)，每个原始的雷达数据都将经过宽度为x的窗口进行平均，平均后的雷达数据比较平滑
4. 计算“相邻雷达点之间的弧度” (radians_per_elem)：在第一次做完数据预处理的1-3步的时候，会根据雷达扫描的弧度范围以及雷达点个数，计算出那个最准确的“最小角度刻度”，并记录，以后就用这个精确值，不再用默认值了

## 制造“安全气泡”（画出“绝对禁区”）
1. 找到最大威胁：在经过数据预处理后的的数据中，算法会找到距离最近的那个点 (proc_ranges.argmin())。这个点就是当前对小车构成最大威胁的障碍物。
2. “膨胀”威胁：算法不会只把这一个点当成障碍。它会以这个最近点为中心，向左和向右扩展一个半径为 BUBBLE_RADIUS 的区域，然后将这个区域内所有的雷达距离值全部强制设为0。这样做是为了给车身留出足够的安全余量。它告诉算法：“这个地方和它附近的一大片区域都绝对不能走，想都不要想！” 这可以有效避免小车试图贴着墙壁或障碍物边缘进行一些危险的“极限穿越”。

## 寻找最大间隙（“找条最宽的路”）
1. 识别所有通道：现在的数据中，有值为0的“禁区”，也有值大于0的“可通行区域”。算法会扫描整个数据，找出所有连续的、大于0的数据段。每一个这样的数据段都代表一个可以通行的“间隙”或“通道”。
2. 选择最宽的通道：算法会比较所有找到的“通道”的宽度（即连续数据段的长度），并选出最长的那一个。

## 在间隙中寻找最佳目标点（“瞄准最开阔的远方”）
1. 评估通道内的视野：算法会聚焦于上一步找到的最大间隙内部。它会再次对这个间隙内的距离数据进行平滑处理。
2. 寻找最“深远”的点：在平滑后的间隙数据中，算法会寻找距离值最大的那个点 (argmax())

## 计算并下达指令（“打方向盘，踩油门”）
1. 计算转向角：get_angle 函数将 best 这个索引转换成一个实际的阿克曼转向角度。它会根据目标点相对于车头正前方的偏移量来计算方向盘该打多少。
2. 动态调速：算法会判断计算出的转向角大小。如果角度很大（说明在急转弯），就降低车速 (CORNERS_SPEED)；如果角度很小（说明在跑直线），就提高车速 (STRAIGHTS_SPEED)。
3. 发布命令：最后，将计算出的转向角和速度打包成一个控制消息，发布出去，让小车执行。